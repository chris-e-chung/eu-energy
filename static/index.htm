<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,300;0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="site.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="scroller.js"></script>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script> -->

    <meta property="og:title" content="Global Energy"/>
    <meta property="og:description" content="This scroll-to-interact visualization shows some of the complicated flows of energy around the world, with a focus on the EU's commitment to carbon neutrality."/>
    <!-- <meta property="og:url" content="https://cuthchow.github.io/college-majors-visualisation/"/> -->

    <title>Global Energy</title>
</head>

<body>
    <div id="graphic">
        <div id="sections">
            <section class="step">
                <h1>The Energy Trade</h1>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin interdum diam a dui interdum, eu suscipit turpis rhoncus. Phasellus accumsan, felis a fringilla iaculis, risus turpis porta lectus, faucibus tincidunt neque leo id nibh. Proin malesuada nisl sed turpis aliquam imperdiet. Nullam leo erat, faucibus ac vestibulum in, sollicitudin vel justo. Mauris sagittis, lectus sed dignissim aliquet, enim eros auctor tortor, id ullamcorper turpis nisi ac arcu. In condimentum porta ex eget fringilla.            </p>
            </section>
            <section class="step">
                <p>
                    I mean, look at all of that trade! It's hard to get a grasp on the finer details. Let's focus on a specific place - say, Germany.
                </p>
            </section>
            <section class="step">
                <p>
                    We can see here that Germany ---------. But in ------, there's a big shift -- ----.
                </p>
                <div id="GermanEnergy">
                    <svg id="svg-line" width="600" height="500" opacity="0"></svg>
                </div>
            </section>
            <section class="step">
                <p>
                    In -----, Russian invaded Ukraine- ------------.
                </p>
            </section>
            <section class="step">
                <p>
                    Praesent aliquam, velit ut interdum efficitur, turpis tellus feugiat metus, non semper justo dui vel elit. Proin euismod lacinia sollicitudin. Interdum et malesuada fames ac ante ipsum primis in faucibus. Duis efficitur, erat non ullamcorper porta, nibh mi aliquam arcu, ac feugiat leo odio et mauris. 
                </p>
            </section>
            <section class="step">
                <p>
                    Look at any country you'd like, here!
                </p>
            </section>
        </div>
        <div id="vis">
            <svg id="svg" width="1000" height="1000"></svg>
        </div>
        <div id="RussianEnergy">
            <svg id="svg-line-2" width="600" height="500" opacity="0"></svg>
        </div>
    </div>

    <script>
        async function requestData() {
            // Boiler plate stuff
            svg = d3.select("svg#svg");
            const width = svg.attr("width");
            const height = svg.attr("height");
            const margins = {left: 170, top: 50, bottom: 50, right: 20}

            // Load in the data for the coordinates
            coords = await d3.csv("data/country-coord.csv");
            // Find Germany, which is the center of our map
            const germany = coords.find((country) => country.Country == "Germany");
            const germanyCoords = [germany["Longitude (average)"], germany["Latitude (average)"]]

            // Creating the map
                // List of country names with IDs
            const countryNames = await d3.tsv("https://unpkg.com/world-atlas@1.1.4/world/50m.tsv");
            const nameById = new Map(countryNames.filter(d => d.iso_n3 !== "-99").map(d => [d.iso_n3, d.admin]))  // or brk_name 
                // Load the TopoJSON
            const worldjson = await d3.json("https://unpkg.com/world-atlas@1.1.4/world/50m.json");
            const geoData = topojson.feature(worldjson, worldjson.objects.countries);
            
            // Add the correct name to each country's properties
            geoData.features.forEach((d, i) => {
                const id = worldjson.objects.countries.geometries[i].id;
                d.id = id;
                d.properties.name = nameById.get(id);  // Now this will not be undefined
            });

            const europeFeatures = geoData.features.filter(f => {
                const bounds = d3.geoBounds(f);  // returns [[west, south], [east, north]]
                const [[minLon, minLat], [maxLon, maxLat]] = bounds;

                    // Rough Europe bounding box (adjust if needed):
                    return (
                        (maxLon >= -10 || maxLon <= -160) &&
                        maxLat >= 30 && minLat <= 100       // Latitude range for Europe
                    );
            });
            
            // Zoom Behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on("zoom", function (event) {
                    svg.selectAll("path").attr("transform", event.transform);
                });
            // Would allow user zooming 
            // svg.call(zoom);

            // Projection documentation:
            // https://d3js.org/d3-geo/projection
            const projection = d3.geoConicConformal()
                            .center(germanyCoords)
                            .scale(width * 1.2)
                            .translate([width / 2, height / 2]);
            const path = d3.geoPath().projection(projection);

            // Add the paths to the svg
            map = svg.append("g").selectAll("path.country").data(europeFeatures)
                .join("path")
                .attr("d", path)
                .attr("class", "country")
                // I chose these colors from here:
                // https://colorhunt.co/palette/89a8b2b3c8cfe5e1daf1f0e8
                .style("stroke", "#F1F0E8")
                .style("stroke-width", '1px')
                .style("fill", "#89A8B2")
                .style("opacity", 0.8);

            // 
            // CREATE THE VISUALIZATIONS
            // 

            // Load in the data
            const tradeLinksData = await d3.csv("data/cleaned_EU_trade.csv", d3.autoType);

            // We'll use the surface area to calculate how much we can randomize the points for the trade links
            const countrySurfaceAreaData = await d3.csv("data/country-sa.csv", d3.autoType);
            var countrySurfaceArea = {};
            countrySurfaceAreaData.forEach(d => {
                countrySurfaceArea[d["Country Name"]] = d["2022"];
            });

            // Draw everything first, but set their visibility to hidden to hide them and show as needed l8r
            // Setting their visibility to hidden doesn't necessarily mean "display: none"
            function pageLoad() {
                // Process the trade data
                // This is Max's code from the old page
                const tradeLinks = tradeLinksData.map(d => {
                    const from = coords.find(c => c.Country === d.partner);
                    const to = coords.find(c => c.Country === d.geo);
                    if (!from || !to) return null;
                    return {
                        partner: d.partner,
                        geo: d.geo,
                        source: [from["Longitude (average)"], from["Latitude (average)"]],
                        target: [to["Longitude (average)"], to["Latitude (average)"]],
                        value: d.OBS_VALUE
                    };
                }).filter(d => d !== null);

                // Having straight lines looks a little weird, so let's curve them
                // Quadratic Bezier curve to draw curves instead of straight lines
                // Basically, take we're finding the point on a perpedicular line to the midpoint of the line between two points

                // @param {[number, number]} coord1 - an array of [x1, y1] where each value is a pixel coordinate x or y
                // @param {[number, number]} coord2 - an array of [x2, y2] where each value is a pixel coordinate x or y
                // @return {[number, number]} an array of [q1, q2] where each value is the pixel coordinate of the perpendicular point
                function bezierCurver(coord1, coord2) {
                    [x1, y1] = coord1;
                    [x2, y2] = coord2;

                    [mx, my] = [(x1 + x2)/2, (y1 + y2)/2];
                    [dx, dy] = [x2 - x1, y2 - y1];

                    length = Math.sqrt(dx**2 + dy**2);

                    // Add some randomness
                    // Math.random() - 0.5 randomizes the sign of the value, so from -0.5 to 0.5
                    // We multiply by two to create an interval [-1, 1)
                    h = (Math.random() - 0.5) * length * 2;

                    result = [mx + (-dy/length) * h, my + (dx/length) * h];

                    return result;
                }

                // Somewhat randomize the location of each point based on the relative size of the country
                // @param {[number, number]} coord - an array of [x1, y2] where each value is an int pixel coordinate
                // @param {string} country - a string representing the name of a country (used to find surface area)
                // @returns {[number, number]} - a pixel coordinate pair randomized based on the surface area of the provided country
                function pointRandomizer(coord, country, randomness=6) {
                    [x, y] = coord;
                    countrySA = countrySurfaceArea[country];

                    // 320 was the smallest SA
                    multiplierx = Math.log(countrySA / 320) * (Math.random() - 0.5) * randomness;
                    multipliery = Math.log(countrySA / 320) * (Math.random() - 0.5) * randomness;

                    if (countrySA) {
                        return [x + multiplierx, y + multipliery];
                    }
                    else {
                        return coord;
                    }
                }

                // Draw the trade lines
                const tradeLines = svg.append("g").selectAll("path.trade-link").data(tradeLinks).join("path")
                                      .attr("class", "trade-link")
                                      .attr("d", d => {
                                            // Randomize the points somewhat so they don't all come out of / go to the same place
                                            coords1 = pointRandomizer(projection(d.source), d.partner);
                                            coords2 = pointRandomizer(projection(d.target), d.geo);
                                            // Add a curve point to make an arc
                                            curvePoint = bezierCurver(coords1, coords2);

                                            return `M ${coords1[0]} ${coords1[1]} Q ${curvePoint[0]} ${curvePoint[1]} ${coords2[0]} ${coords2[1]}`
                                      })
                                      .attr("from", d => d.partner)
                                      .attr("to", d => d.geo)
                                      .style("fill", "none")
                                      .style("stroke", "black")
                                      .style("stroke-width", "1px")
                                      .style("opacity", 1);

                // Add some important parts
                // First, set the stroke settings. It was hard to do this when first drawing them because
                //      we need to calculate the length of the path
                //
                // How the line animation works: https://medium.com/@louisemoxy/create-a-d3-line-chart-animation-336f1cb7dd61
                //      some additional docs:    https://observablehq.com/@onoratod/animate-a-path-in-d3
                // Basically, offset the path's stroke by the length of the path, making it basically offscreen for itself
                // Then, bring it back by setting the offset to 0
                tradeLines.each(function(d, i) {
                    // Set the initial stroke stuff
                    // Makes it invisible
                    const pathLength = this.getTotalLength();
                    d3.select(this)
                      .attr("stroke-dasharray", pathLength + " " + pathLength)
                      .attr("stroke-dashoffset", pathLength);

                    // Add the circles at the beginning and end of each path
                    const startCircleCoords = this.getPointAtLength(0);
                    const endCircleCoords = this.getPointAtLength(pathLength);
                    // Set the opacity to 0 so they're not visible
                    svg.append("circle")
                       .attr("class", "trade-link-circle start")
                       .attr("id", "start" + i)
                       .attr("cx", c => Math.round(startCircleCoords.x))
                       .attr("cy", c => Math.round(startCircleCoords.y))
                       .attr("r", 2)
                       .style("opacity", 0)
                    svg.append("circle")
                       .attr("class", "trade-link-circle end")
                       .attr("id", "end" + i)
                       .attr("cx", c => Math.round(endCircleCoords.x))
                       .attr("cy", c => Math.round(endCircleCoords.y))
                       .attr("r", 2)
                       .style("opacity", 0);
                });

                // Store every reversed DOM list we have
                reversedCircles = {};
                async function drawLineChart(svgSelector, csvPath, name) {
                    const selectedSVG = d3.select(svgSelector)
                    const width = selectedSVG.attr("width");
                    const height = selectedSVG.attr("height");
                    const margin = {top: 10, right: 10, bottom: 50, left: 50};
                    const chartWidth = width - margin.left - margin.right;
                    const chartHeight = height - margin.top - margin.bottom;

                    let annotations = selectedSVG.append("g").attr("id","annotations");
                        // No translate here since our annotations may be outside of the chart area
                    let chartArea = selectedSVG.append("g").attr("id","points")
                        .attr("transform","translate("+margin.left+","+margin.top+")");

                    // Reformat data 
                    let dataset = await d3.csv(csvPath, d3.autoType);
                    const longData = [];
                    dataset.forEach(row => {
                        const type = row.Type;
                        if (type === "Consumption" || type === "Exports" || type === "Imports") return;
                        Object.keys(row).forEach(key => {
                            if (key !== "Type") {
                                const year = +key;
                                const value = +row[key];
                                if (!isNaN(year) && !isNaN(value)) {
                                    longData.push({ type, year, value });
                                }
                            }
                        });
                    });

                    const yearExtent = d3.extent(longData, d => d.year);
                    const yearScale = d3.scaleLinear().domain(yearExtent).range([0, chartWidth]);

                    const valueExtent = d3.extent(longData, d => d.value);
                    const valueScale = d3.scaleLinear().domain(valueExtent).range([chartHeight, 0]);

                    const energyTypes = [
                        "Nuclear",
                        "Fossil fuels",
                        "Coal",
                        "Natural gas",
                        "Oil",
                        "Renewables",
                        "Hydroelectricity",
                        "Geothermal",
                        "Solar, tide, wave, fuel cell",
                        "Wind",
                        "Solar, tide, wave, fuel cell",
                    ];
                    // These were ChatGPT'd
                    const energyColors = [
                        "#00FF7F", // Nuclear (bright yellow/orange, radiation symbol color)
                        "#7F7F7F", // Fossil fuels (neutral grey, industrial tone)
                        "#111111", // Coal (black, literal coal color)
                        "#C1440E", // Natural gas (burnt orange, gas flame)
                        "#8B0000", // Oil (dark red, oil spill tone)
                        "#2E8B57", // Renewables (forest green)
                        "#4682B4", // Hydroelectricity (steel blue, water theme)
                        "#BA55D3", // Geothermal (purple, earth/heat theme)
                        "#FFD700", // Solar, tide, wave, fuel cell (gold/yellow for sun)
                        "#1E90FF", // Wind (sky blue, air/wind)
                        "#FFA500"  // Solar, tide, wave, fuel cell (orange, alternate sun/wave color)
                    ];
                    const colorScale = d3.scaleOrdinal(energyTypes, energyColors);

                    const leftAxis = d3.axisLeft(valueScale)
                                    .tickFormat(d3.format(".2s"));

                    const bottomAxis = d3.axisBottom(yearScale)
                                        .tickFormat(d3.format("~f"));

                    // Append axes
                    annotations.append("g")
                        .attr("class", "y axis")
                        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
                        .call(leftAxis)
                        .style("opacity", 0);

                    annotations.append("g")
                        .attr("class", "x axis")
                        .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
                        .call(bottomAxis)
                        .style("opacity", 0);

                    const line = d3.line()
                        .defined(d => !isNaN(d.value) && !isNaN(d.year))
                        .x(d => yearScale(d.year))
                        .y(d => valueScale(d.value));

                    // Group data by type
                    const dataByType = d3.group(longData, d => d.type);

                    // Plot lines
                    energyLines = chartArea.selectAll(`path.${name}-line`)
                        .data(dataByType)
                        .join("path")
                        .attr("class", `${name}-line`)
                        .attr("d", ([type, values]) => line(values))
                        .attr("fill", "none")
                        .attr("stroke", ([type]) => colorScale(type))
                        .attr("stroke-width", 2);

                    for (let [type, values] of dataByType) {
                        if (type !== "Exports" && type !== "Imports" && type !== "Consumption") {
                            let first = true;
                            let prevX;
                            let prevY;
                            let sum = 0;

                            d3.select(svgSelector).append("g")
                                .selectAll(`circle.${name}-circle`)
                                .data(values)
                                .join("circle")
                                .attr("class", `${name}-circle`)
                                .attr("cx", d => yearScale(d.year) + margin.left)
                                .attr("cy", d => valueScale(d.value) + margin.top)
                                .attr("sum", function(d) {
                                    cx = yearScale(d.year) + margin.left;
                                    cy = valueScale(d.value) + margin.top;

                                    if (first) {
                                        prevX = cx;
                                        prevY = cy;
                                        first = false;
                                    };
                                    distanceFromPrevPoint = Math.hypot(prevX - cx, prevY - cy)
                                    result = Math.round(sum + distanceFromPrevPoint);

                                    prevX = cx;
                                    prevY = cy;
                                    sum = result;
                                    return result
                                })
                                .attr("r", 0)
                                .attr("fill", colorScale(type))
                                .style("opacity", 1);
                            }
                        }

                    const legendGroup = selectedSVG.append("g")
                        .attr("class", "legend-group")
                        .attr("transform", `translate(${0}, ${0})`)
                        .style("z-index", 2)
                        .style("opacity", 0);

                    const legend = legendGroup.selectAll(".legend")
                        .data(dataByType.keys())
                        .join("g")
                        .attr("class", "legend")
                        .attr("transform", (d, i) => `translate(0,${i * 20})`);

                    legend.append("rect")
                        .attr("x", 0)
                        .attr("width", 10)
                        .attr("height", 10)
                        .attr("fill", d => colorScale(d));

                    legend.append("text")
                        .attr("x", 15)
                        .attr("y", 9)
                        .text(d => d);
                    
                    legendGroup.raise();    
                    
                    energyLines.each(function(d, i) {
                        const pathLength = this.getTotalLength();

                        d3.select(this)
                        .attr("stroke-dasharray", pathLength + " " + pathLength)
                        .attr("stroke-dashoffset", pathLength);
                    })

                const newCircles = d3.selectAll(
                    d3.selectAll(`circle.${name}-circle`).nodes().reverse()
                );
                reversedCircles[name] = newCircles;
            }
                
            drawLineChart("#svg-line", "data/germany_energy.csv", "germany")
            drawLineChart("#svg-line-2", "data/russian_energy.csv", "russia")
            // Draw a line representing the start of Russo Ukranian

                // Russian and Ukranian energy production

                // Play with yourself (What?)
            }
            pageLoad();

            // resets zoom form to zoomIdentity original zoom
            function zoomOutToWorld(duration) {
                svg.transition()
                   .duration(duration)
                   .call(
                    zoom.transform,
                    d3.zoomIdentity 
                );
            }

            // The following functions are called whenever we need to make something visible
            // They shouldn't 'add' anything to the svg - only edit visibility via opacity, radius, etc.

            // SOME TIMING VARIABLES:

            const disappearDuration = 500;
            const appearDuration = disappearDuration;
            const linkDuration = 800;
            const delayMultiplier = 12;

            const germanLineDuration = 4000;
            const circleDuration = 500;           

            const zoomInDuration = 3000;
            const zoomOutDuration = zoomInDuration;

            // By draw, we mean make visible - they should already be created on the svg
            // Draw the map
            function draw0() {
                clean("plainMap");

                svg.selectAll("path.country")
                    .transition()
                    .duration(500)
                    .style("opacity", 0.8);
            }

            // Create a dict to keep track of all of the timeouts that we currently have running
            const tradeLinkTimeouts = {};
            let tradeLinkActive = true;

            // Draw the trade links
            function draw1() {
                clean("tradeLinks");
                tradeLinkActive = true;

                svg.selectAll("path.country")
                    .transition()
                    .duration(disappearDuration)
                    .style("opacity", 0.8);

                let tradeLines = svg.selectAll("path.trade-link");

                // Use the amt of trade lines to determine delay later
                length = tradeLines.size();
                // Arbitrary duration
                
                tradeLines.each(function(d, i) {
                    const pathLength = this.getTotalLength();
                    // We rely on delay to determine when each path and beginning circle should be shown
                    // We also later add the duration to the delay to determine when the end circle should be shown
                    const delay = length * Math.random() * delayMultiplier;
                    eachObject = this;

                    // Make it into a function so that we can call it repeatedly
                    // @param d3Object - a tradeLine
                    function repeat(d3Object) {
                        if (!tradeLinkActive) return;

                        // Set the visibility to 0 if it isn't already
                        d3.select(d3Object)
                            .transition()
                            .duration(disappearDuration)
                            .attr("stroke-dashoffset", pathLength)
                            .style("opacity", 0)
                        d3.select(`circle#start${i}`)
                            .transition()
                            .duration(disappearDuration)
                            .style("opacity", 0);
                        d3.select(`circle#end${i}`)
                            .transition()
                            .duration(0)
                            .style("opacity", 0);

                        // Now, make them visible
                        d3.select(d3Object)
                            .transition()
                            .delay(delay)
                            // d3.ease documentation:
                            // https://d3js.org/d3-ease
                            .ease(d3.easePoly.exponent(4))
                            .attr("stroke-dashoffset", 0)
                            .style("opacity", 1)
                            .duration(linkDuration);
                        d3.select(`circle#start${i}`)
                            .transition()
                            .delay(delay)
                            .style("opacity", 1);
                        d3.select(`circle#end${i}`)
                            .transition()
                            .delay(delay + linkDuration)
                            .style("opacity", 1)
                            .on("end", () => {
                                // When we end our animation, queue up another one by repeating the whole thing
                                // Add the timeout to our dict to keep track of it
                                tradeLinkTimeouts[i] = setTimeout(() => repeat(d3Object), delay + linkDuration + 2000);
                            });
                        }
                        // Initially call repeat to get the whole thing started
                        repeat(eachObject);
                    })
                }

            // German energy production
            function draw2() {
                clean("germanEnergy");
                // keep opcaity of map
                svg.selectAll("path.country")
                        .transition()
                        .duration(500)
                        .style("opacity", 1)
                // zoom into map
                const [gx, gy] = projection(germanyCoords);
                const zoomScale = 4;
                const tx = width / 2 - gx * zoomScale;
                const ty = height / 2 - gy * zoomScale;
                
                // Animate zoom to Germany
                svg.transition().duration(1000).call(
                    zoom.transform,
                    d3.zoomIdentity
                        .translate(tx, ty)
                        .scale(zoomScale)
                );
                
                // Outline Germany
                svg.selectAll("path.country")
                        .transition()
                        .duration(500)
                        .style("opacity", d => d.properties.name === "Germany" ? 1 : 0.4)
                        // .style("stroke", d => d.properties.name === "Germany" ? "black" : "white")
                        // .style("stroke-width", d => d.properties.name === "Germany" ? 2 : 1);

                // show the line graph

                d3.select("#svg-line").transition().duration(appearDuration).style("opacity", 1);

                d3.selectAll("path.germany-line").each(function(d, i) {
                    const pathLength = this.getTotalLength();

                    d3.select(this)
                        .transition()
                        // d3.ease documentation:
                        // https://d3js.org/d3-ease
                        .ease(d3.easeLinear)
                        .attr("stroke-dashoffset", 0)
                        .style("opacity", 1)
                        .duration(germanLineDuration);
                });

                maxSum = 0;
                reversedCircles["germany"].each(function(d) {
                    let d3Object = d3.select(this);
                    let circleSum = parseInt(d3Object.attr("sum"));

                    if (maxSum < 1) {
                        maxSum = circleSum;
                    }

                    let circleDelay = Math.round(circleSum / maxSum * germanLineDuration);

                    d3Object.transition()
                            .delay(circleDelay)
                            .ease(d3.easeBackOut)
                            .attr("r", 4)
                            .duration(circleDuration);

                    if (circleSum < 1) {
                        maxSum = circleSum;
                    }
                });

                d3.select('.legend-group').transition().duration(500).style("opacity", 1);
                d3.selectAll(".x.axis").transition().duration(500).style("opacity", 1);
                d3.selectAll(".y.axis").transition().duration(500).style("opacity", 1);
            }

            // Draw a line representing the start of Russo Ukranian
            function draw3() {
                clean("RussiaInvades");
                // keep opcaity of map
                svg.selectAll("path.country")
                        .transition()
                        .duration(500)
                        .style("opacity", d => d.properties.name === "Germany" || d.properties.name === "Russia" ? 1 : 0.4)
                        // .style("stroke", d => d.properties.name === "Germany" ? "black" : "white")
                        // .style("stroke-width", d => d.properties.name === "Germany" ? 2 : 1);
                // zoom rest identity

                zoomOutToWorld(zoomOutDuration)
                // show the line graph
                d3.select("#svg-line").transition().duration(500).style("opacity", 1);
                d3.select('.legend-group').transition().duration(500).style("opacity", 1);
                d3.selectAll(".x.axis").transition().duration(500).style("opacity", 1);
                d3.selectAll(".y.axis").transition().duration(500).style("opacity", 1);
            }

            // Russian and Ukranian energy production
            function draw4() {
                clean("someOtherChart");

            }

            // Play with yourself (What?)
            function draw5() {
                clean("someOtherChart");

            }

            // Stores all of the drawing functions so we can easily refer to them
            activationFunctions = [
                draw0,
                draw1,
                draw2,
                draw3,
                draw4,
                draw5
            ]

            // Removes visibility from every other chart than the one specified
            // @param {string} chartType - a str of the chart to clean for (the only one we're making visible)
            function clean(chartType) {
                // If we're NOT looking at the tradelinks viz
                if (chartType !== "tradeLinks") {
                    tradeLinkActive = false;

                    svg.selectAll("circle.start")
                        .transition()
                        .duration(disappearDuration)
                        .style("opacity", 0);

                    svg.selectAll("circle.end")
                        .transition()
                        .duration(disappearDuration / 3)
                        .style("opacity", 0);

                    // Then, interrupt every current transition and set visibility to 0
                    svg.selectAll("path.trade-link").each(function(d) {
                        const pathLength = this.getTotalLength();
                        d3.select(this)
                            .interrupt()
                            .transition()
                            .duration(disappearDuration)
                            .style("opacity", 0)
                            .attr("stroke-dashoffset", pathLength);
                    })

                    // Interrupt every timeout in the dict
                    for (const key in tradeLinkTimeouts) {
                        clearTimeout(tradeLinkTimeouts[key]);
                    }
                }

                if (chartType !== "germanEnergy" || chartType !== "RussiaInvades") {
                        // d3.select("#svg-line").style("opacity", 0);
                    d3.select("#svg-line").transition().duration(disappearDuration).style("opacity", 0);
                    d3.selectAll("path.germany-line").each(function(d) {
                        const pathLength = this.getTotalLength();
                        d3.select(this)
                            .interrupt()
                            .transition()
                            .duration(disappearDuration / 2)
                            .style("opacity", 0)
                            .attr("stroke-dashoffset", pathLength);
                    });

                    maxSum = 0;
                    reversedCircles["germany"].each(function(d) {
                        let d3Object = d3.select(this);
                        let circleSum = parseInt(d3Object.attr("sum"));

                        if (maxSum < 1) {
                            maxSum = circleSum;
                        }

                        let circleDelay = Math.round(( 1 - circleSum / maxSum) * disappearDuration / 2);

                        d3Object.transition()
                                .delay(circleDelay)
                                .ease(d3.easeBackOut)
                                .attr("r", 0)
                                .duration(circleDuration);

                        if (circleSum < 1) {
                            maxSum = circleSum;
                        }
                    });
                    d3.select('.legend-group').transition().duration(disappearDuration).style("opacity", 0);
                    d3.selectAll(".x.axis").transition().duration(disappearDuration).style("opacity", 0);
                    d3.selectAll(".y.axis").transition().duration(500).style("opacity", 0);

                    zoomOutToWorld(0)
                }

                // If we're NOT looking at the tradelinks viz OR the initial map
                if (!["tradeLinks", "plainMap"].includes(chartType)) {
                    svg.selectAll("path.country")
                        .transition()
                        .duration(disappearDuration)
                        .style("opacity", 0)
                }

                // TODO
                // Add more cleaning for the specific visualizations
                // For example, add a if(chartType !== "germanEnergy")
            }

            // Credit for the scroller code:
            // https://vallandingham.me/scroller.html 
            let scroll = scroller().container(d3.select('#graphic'));
            scroll();

            let lastIndex, activeIndex = 0;

            scroll.on('active', function(index) {
                d3.selectAll('.step')
                    .transition().duration(500)
                    .style('opacity', function (d, i) {return i === index ? 1 : 0.1;});
                
                activeIndex = index
                let sign = (activeIndex - lastIndex) < 0 ? -1 : 1; 
                let scrolledSections = d3.range(lastIndex + sign, activeIndex + sign, sign);
                scrolledSections.forEach(i => {
                    activationFunctions[i]();
                })
                lastIndex = activeIndex;
            })
        };
        requestData();
    </script>
</body>

</html>