<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,300;0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="site.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="scroller.js"></script>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script> -->

    <meta property="og:title" content="Global Energy"/>
    <meta property="og:description" content="This scroll-to-interact visualization shows some of the complicated flows of energy around the world, with a focus on the EU's commitment to carbon neutrality."/>
    <!-- <meta property="og:url" content="https://cuthchow.github.io/college-majors-visualisation/"/> -->

    <title>Global Energy</title>
</head>

<body>
    <div id="graphic">
        <div id="sections">
            <section class="step">
                <h1>The Energy Trade</h1>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin interdum diam a dui interdum, eu suscipit turpis rhoncus. Phasellus accumsan, felis a fringilla iaculis, risus turpis porta lectus, faucibus tincidunt neque leo id nibh. Proin malesuada nisl sed turpis aliquam imperdiet. Nullam leo erat, faucibus ac vestibulum in, sollicitudin vel justo. Mauris sagittis, lectus sed dignissim aliquet, enim eros auctor tortor, id ullamcorper turpis nisi ac arcu. In condimentum porta ex eget fringilla.            </p>
            </section>
            <section class="step">
                <p>
                    I mean, look at all of that trade! It's hard to get a grasp on the finer details. Let's focus on a specific place - say, Germany.
                </p>
            </section>
            <section class="step">
                <p>
                    We can see here that Germany ---------. But in ------, there's a big shift -- ----.
                </p>
            </section>
            <section class="step">
                <p>
                    In -----, Russian invaded Ukraine- ------------.
                </p>
            </section>
            <section class="step">
                <p>
                    Praesent aliquam, velit ut interdum efficitur, turpis tellus feugiat metus, non semper justo dui vel elit. Proin euismod lacinia sollicitudin. Interdum et malesuada fames ac ante ipsum primis in faucibus. Duis efficitur, erat non ullamcorper porta, nibh mi aliquam arcu, ac feugiat leo odio et mauris. 
                </p>
            </section>
            <section class="step">
                <p>
                    Look at any country you'd like, here!
                </p>
            </section>
        </div>
        <div id="vis">
            <svg id="svg" width="1000" height="1000"></svg>
        </div>
    </div>

    <script>
        async function requestData() {
            // Boiler plate stuff
            svg = d3.select("svg#svg");
            const width = svg.attr("width");
            const height = svg.attr("height");
            const margins = {left: 170, top: 50, bottom: 50, right: 20}

            // Load in the data for the coordinates
            coords = await d3.csv("data/country-coord.csv");
            // Find Germany, which is the center of our map
            const germany = coords.find((country) => country.Country == "Germany");
            const germanyCoords = [germany["Longitude (average)"], germany["Latitude (average)"]]

            // Creating the map
            worldjson = await d3.json("https://unpkg.com/world-atlas@1.1.4/world/50m.json");
            geoData = topojson.feature(worldjson, worldjson.objects.countries);

            // Projection documentation:
            // https://d3js.org/d3-geo/projection
            const projection = d3.geoConicConformal()
                            .center(germanyCoords)
                            .scale(width * 1.2)
                            .translate([width / 2, height / 2]);
            const path = d3.geoPath().projection(projection);

            // Add the paths to the svg
            map = svg.append("g").selectAll("path.country").data(geoData.features)
                .join("path")
                .attr("d", path)
                .attr("class", "country")
                // I chose these colors from here:
                // https://colorhunt.co/palette/89a8b2b3c8cfe5e1daf1f0e8
                .style("stroke", "#F1F0E8")
                .style("stroke-width", '1px')
                .style("fill", "#89A8B2")
                .style("opacity", 0.8);

            // 
            // CREATE THE VISUALIZATIONS
            // 

            // Load in the data
            const tradeLinksData = await d3.csv("data/cleaned_EU_trade.csv", d3.autoType);

            // We'll use the surface area to calculate how much we can randomize the points for the trade links
            const countrySurfaceAreaData = await d3.csv("data/country-sa.csv", d3.autoType);
            var countrySurfaceArea = {};
            countrySurfaceAreaData.forEach(d => {
                countrySurfaceArea[d["Country Name"]] = d["2022"];
            });

            // Draw everything first, but set their visibility to hidden to hide them and show as needed l8r
            // Setting their visibility to hidden doesn't necessarily mean "display: none"
            function pageLoad() {
                // Process the trade data
                // This is Max's code from the old page
                const tradeLinks = tradeLinksData.map(d => {
                    const from = coords.find(c => c.Country === d.partner);
                    const to = coords.find(c => c.Country === d.geo);
                    if (!from || !to) return null;
                    return {
                        partner: d.partner,
                        geo: d.geo,
                        source: [from["Longitude (average)"], from["Latitude (average)"]],
                        target: [to["Longitude (average)"], to["Latitude (average)"]],
                        value: d.OBS_VALUE
                    };
                }).filter(d => d !== null);

                // Having straight lines looks a little weird, so let's curve them
                // Quadratic Bezier curve to draw curves instead of straight lines
                // Basically, take we're finding the point on a perpedicular line to the midpoint of the line between two points

                // @param {[number, number]} coord1 - an array of [x1, y1] where each value is a pixel coordinate x or y
                // @param {[number, number]} coord2 - an array of [x2, y2] where each value is a pixel coordinate x or y
                // @return {[number, number]} an array of [q1, q2] where each value is the pixel coordinate of the perpendicular point
                function bezierCurver(coord1, coord2) {
                    [x1, y1] = coord1;
                    [x2, y2] = coord2;

                    [mx, my] = [(x1 + x2)/2, (y1 + y2)/2];
                    [dx, dy] = [x2 - x1, y2 - y1];

                    length = Math.sqrt(dx**2 + dy**2);

                    // Add some randomness
                    // Math.random() - 0.5 randomizes the sign of the value, so from -0.5 to 0.5
                    // We multiply by two to create an interval [-1, 1)
                    h = (Math.random() - 0.5) * length * 2;

                    result = [mx + (-dy/length) * h, my + (dx/length) * h];

                    return result;
                }

                // Somewhat randomize the location of each point based on the relative size of the country
                // @param {[number, number]} coord - an array of [x1, y2] where each value is an int pixel coordinate
                // @param {string} country - a string representing the name of a country (used to find surface area)
                // @returns {[number, number]} - a pixel coordinate pair randomized based on the surface area of the provided country
                function pointRandomizer(coord, country, randomness=6) {
                    [x, y] = coord;
                    countrySA = countrySurfaceArea[country];

                    // 320 was the smallest SA
                    multiplierx = Math.log(countrySA / 320) * (Math.random() - 0.5) * randomness;
                    multipliery = Math.log(countrySA / 320) * (Math.random() - 0.5) * randomness;

                    if (countrySA) {
                        return [x + multiplierx, y + multipliery];
                    }
                    else {
                        return coord;
                    }
                }

                // Draw the trade lines
                const tradeLines = svg.append("g").selectAll("path.trade-line").data(tradeLinks).join("path")
                                      .attr("class", "trade-link")
                                      .attr("d", d => {
                                            // Randomize the points somewhat so they don't all come out of / go to the same place
                                            coords1 = pointRandomizer(projection(d.source), d.partner);
                                            coords2 = pointRandomizer(projection(d.target), d.geo);
                                            // Add a curve point to make an arc
                                            curvePoint = bezierCurver(coords1, coords2);

                                            return `M ${coords1[0]} ${coords1[1]} Q ${curvePoint[0]} ${curvePoint[1]} ${coords2[0]} ${coords2[1]}`
                                      })
                                      .attr("from", d => d.partner)
                                      .attr("to", d => d.geo)
                                      .style("fill", "none")
                                      .style("stroke", "black")
                                      .style("stroke-width", "1px")
                                      .style("opacity", 1);

                // Add some important parts
                // First, set the stroke settings. It was hard to do this when first drawing them because
                //      we need to calculate the length of the path
                //
                // How the line animation works: https://medium.com/@louisemoxy/create-a-d3-line-chart-animation-336f1cb7dd61
                //      some additional docs:    https://observablehq.com/@onoratod/animate-a-path-in-d3
                // Basically, offset the path's stroke by the length of the path, making it basically offscreen for itself
                // Then, bring it back by setting the offset to 0
                tradeLines.each(function(d, i) {
                    // Set the initial stroke stuff
                    // Makes it invisible
                    const pathLength = this.getTotalLength();
                    d3.select(this)
                      .attr("stroke-dasharray", pathLength + " " + pathLength)
                      .attr("stroke-dashoffset", pathLength);

                    // Add the circles at the beginning and end of each path
                    const startCircleCoords = this.getPointAtLength(0);
                    const endCircleCoords = this.getPointAtLength(pathLength);
                    // Set the opacity to 0 so they're not visible
                    svg.append("circle")
                       .attr("class", "trade-link-circle")
                       .attr("id", "start" + i)
                       .attr("cx", c => Math.round(startCircleCoords.x))
                       .attr("cy", c => Math.round(startCircleCoords.y))
                       .attr("r", 1)
                       .style("opacity", 0)
                    svg.append("circle")
                       .attr("class", "trade-link-circle")
                       .attr("id", "end" + i)
                       .attr("cx", c => Math.round(endCircleCoords.x))
                       .attr("cy", c => Math.round(endCircleCoords.y))
                       .attr("r", 1)
                       .style("opacity", 0);
                });

                //
                // TODO
                // CONTINUE INITIALIZIZING EVERYTHING WE NEED TO DRAW HERE
                //
                
                // German energy production

                // Draw a line representing the start of Russo Ukranian

                // Russian and Ukranian energy production

                // Play with yourself (What?)




                // The following functions are called whenever we need to make something visible
                // They shouldn't 'add' anything to the svg - only edit visibility via opacity, radius, etc.

                // By draw, we mean make visible - they should already be created on the svg
                // Draw the map
                function draw0() {
                    clean("plainMap");

                    svg.selectAll("path.country")
                      .transition()
                      .duration(500)
                      .style("opacity", 0.8);
                }

                // Create a dict to keep track of all of the timeouts that we currently have running
                const tradeLinkTimeouts = {};
                // Draw the trade links
                function draw1() {
                    clean("tradeLinks");

                    svg.selectAll("path.country")
                      .transition()
                      .duration(500)
                      .style("opacity", 0.8);

                    // Use the amt of trade lines to determine delay later
                    length = tradeLines.size();
                    // Arbitrary duration
                    const linkDuration = 800;
                    // Delay multiplier that is directly applied to delay
                    const delayMultiplier = 12;
                   
                    tradeLines.each(function(d, i) {
                        const pathLength = this.getTotalLength();
                        // We rely on delay to determine when each path and beginning circle should be shown
                        // We also later add the duration to the delay to determine when the end circle should be shown
                        const delay = length * Math.random() * delayMultiplier;
                        eachObject = this;

                        // Make it into a function so that we can call it repeatedly
                        // @param d3Object - a tradeLine
                        function repeat(d3Object) {
                            // Set the visibility to 0 if it isn't already
                            d3.select(d3Object)
                                .transition()
                                .duration(500)
                                .attr("stroke-dashoffset", pathLength)
                                .style("opacity", 0)
                            d3.select(`circle#start${i}`)
                                .transition()
                                .duration(0)
                                .style("opacity", 0);
                            d3.select(`circle#end${i}`)
                                .transition()
                                .duration(0)
                                .style("opacity", 0);

                            // Now, make them visible
                            d3.select(d3Object)
                                .transition()
                                .delay(delay)
                                // d3.ease documentation:
                                // https://d3js.org/d3-ease
                                .ease(d3.easePoly.exponent(4))
                                .attr("stroke-dashoffset", 0)
                                .style("opacity", 1)
                                .duration(linkDuration);
                            d3.select(`circle#start${i}`)
                                .transition()
                                .delay(delay)
                                .style("opacity", 1);
                            d3.select(`circle#end${i}`)
                                .transition()
                                .delay(delay + linkDuration)
                                .style("opacity", 1)
                                .on("end", () => {
                                    // When we end our animation, queue up another one by repeating the whole thing
                                    // Add the timeout to our dict to keep track of it
                                    tradeLinkTimeouts[i] = setTimeout(() => repeat(d3Object), delay + linkDuration + 2000);
                                });
                            }
                            // Initially call repeat to get the whole thing started
                            repeat(eachObject);
                        })
                    }


                // TODO
                // Add functionality to the drawing functions for the viz's
            
                // German energy production
                function draw2() {
                    clean("someOtherChart");
                }

                // Draw a line representing the start of Russo Ukranian
                function draw3() {
                    clean("someOtherChart");
                }

                // Russian and Ukranian energy production
                function draw4() {
                    clean("someOtherChart");

                }

                // Play with yourself (What?)
                function draw5() {
                    clean("someOtherChart");

                }

                // Stores all of the drawing functions so we can easily refer to them
                activationFunctions = [
                    draw0,
                    draw1,
                    draw2,
                    draw3,
                    draw4,
                    draw5
                ]

                // Removes visibility from every other chart than the one specified
                // @param {string} chartType - a str of the chart to clean for (the only one we're making visible)
                function clean(chartType) {

                    // If we're NOT looking at the tradelinks viz
                    if (chartType !== "tradeLinks") {
                        svg.selectAll("circle.trade-link-circle").transition().duration(0).style("opacity", 0);

                        // Interrupt every timeout in the dict
                        for (const key in tradeLinkTimeouts) {
                            clearTimeout(tradeLinkTimeouts[key]);
                        }

                        // Then, interrupt every current transition and set visibility to 0
                        tradeLines.each(function(d) {
                            const pathLength = this.getTotalLength();
                            d3.select(this)
                              .interrupt()
                              .transition()
                              .duration(500)
                              .style("opacity", 0)
                              .attr("stroke-dashoffset", pathLength);
                        })
                    }

                    // If we're NOT looking at the tradelinks viz OR the initial map
                    if (!["tradeLinks", "plainMap"].includes(chartType)) {
                        svg.selectAll("path.country")
                           .transition()
                           .duration(500)
                           .style("opacity", 0)
                    }

                    // TODO
                    // Add more cleaning for the specific visualizations
                    // For example, add a if(chartType !== "germanEnergy")

                }

                // Credit for the scroller code:
                // https://vallandingham.me/scroller.html 
                let scroll = scroller().container(d3.select('#graphic'));
                scroll();

                let lastIndex, activeIndex = 0;

                scroll.on('active', function(index) {
                    d3.selectAll('.step')
                        .transition().duration(500)
                        .style('opacity', function (d, i) {return i === index ? 1 : 0.1;});
                    
                    activeIndex = index
                    let sign = (activeIndex - lastIndex) < 0 ? -1 : 1; 
                    let scrolledSections = d3.range(lastIndex + sign, activeIndex + sign, sign);
                    scrolledSections.forEach(i => {
                        activationFunctions[i]();
                    })
                    lastIndex = activeIndex;
                })
            }
            pageLoad();

        };
        requestData();
    </script>
</body>

</html>